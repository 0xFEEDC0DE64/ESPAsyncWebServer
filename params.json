{
  "name": "ESPAsyncWebServer",
  "tagline": "Async HTTP and WebSocket Server for ESP8266 and ESP32 Arduino",
  "body": "# ESPAsyncWebServer\r\nAsync HTTP and WebSocket Server for ESP8266 and ESP32/ESP31B Arduino\r\n\r\nRequires [ESPAsyncTCP](https://github.com/me-no-dev/ESPAsyncTCP) to work\r\n\r\n## Why should you care\r\n- Using asynchronous network means that you can handle more than one connection at the same time\r\n- You are called once the request is ready and parsed\r\n- When you send the response, you are immediately ready to handle other connections\r\n  while the server is taking care of sending the response in the background\r\n- Speed is OMG\r\n- Easy to use API, HTTP Basic Authentication, ChunkedResponse\r\n- Easily extendible to handle any type of content\r\n- Supports Continue 100\r\n- Async WebSocket plugin offering different locations without extra servers or ports\r\n\r\n## Important things to remember\r\n- This is fully asynchronous server and as such does not run on the loop thread.\r\n- You can not use yield or delay or any function that uses them inside the callbacks\r\n- The server is smart enough to know when to close the connection and free resources\r\n- You can not send more than one response to a single request\r\n\r\n## Principles of operation\r\n\r\n### The Async Web server\r\n- Listens for connections\r\n- Wraps the new clients into ```Request```\r\n- Keeps track of clients and cleans memory\r\n- Manages ```Handlers``` and attaches them to Requests\r\n\r\n### Request Life Cycle\r\n- TCP connection is received by the server\r\n- The connection is wrapped inside ```Request``` object\r\n- When the request head is received (type, url, get params, http version and host),\r\n  the server goes through all attached ```Handlers```(in the order they are attached) trying to find one\r\n  that ```canHandle``` the given request. If none are found, the default(catch-all) handler is attached.\r\n- The rest of the request is received, calling the ```handleUpload``` or ```handleBody``` methods of the ```Handler``` if they are needed (POST+File/Body)\r\n- When the whole request is parsed, the result is given to the ```handleRequest``` method of the ```Handler``` and is ready to be responded to\r\n- In the ```handleRequest``` method, to the ```Request``` is attached a ```Response``` object (see below) that will serve the response data back to the client\r\n- When the ```Response``` is sent, the client is closed and freed from the memory\r\n\r\n### Handlers and how do they work\r\n- The ```Handlers``` are used for executing specific actions to particular requests\r\n- One ```Handler``` instance can be attached to any request and lives together with the server\r\n- The ```canHandle``` method is used for filtering the requests that can be handled\r\n  and declaring any interesting headers that the ```Request``` should collect \r\n- Decision can be based on request method, request url, http version, request host/port/target host and GET parameters\r\n- Once a ```Handler``` is attached to given ```Request``` (```canHandle``` returned true)\r\n  that ```Handler``` takes care to receive any file/data upload and attach a ```Response```\r\n  once the ```Request``` has been fully parsed\r\n- ```Handler's``` ```canHandle``` is called in the order they are attached to the server.\r\n  If a ```Handler``` attached earlier returns ```true``` on ```canHandle```, then this ```Hander's``` ```canHandle``` will never be called\r\n\r\n### Responses and how do they work\r\n- The ```Response``` objects are used to send the response data back to the client\r\n- The ```Response``` object lives with the ```Request``` and is freed on end or disconnect\r\n- Different techniques are used depending on the response type to send the data in packets\r\n  returning back almost immediately and sending the next packet when this one is received.\r\n  Any time in between is spent to run the user loop and handle other network packets\r\n- Responding asynchronously is probably the most difficult thing for most to understand\r\n- Many different options exist for the user to make responding a background task\r\n\r\n\r\n## Request Variables\r\n\r\n### Common Variables\r\n```cpp\r\nrequest->version();       // uint8_t: 0 = HTTP/1.0, 1 = HTTP/1.1\r\nrequest->method();        // enum:    HTTP_GET, HTTP_POST, HTTP_DELETE, HTTP_PUT, HTTP_PATCH, HTTP_HEAD, HTTP_OPTIONS\r\nrequest->url();           // String:  URL of the request (not including host, port or GET parameters) \r\nrequest->host();          // String:  The requested host (can be used for virtual hosting)\r\nrequest->contentType();   // String:  ContentType of the request (not avaiable in Handler::canHandle)\r\nrequest->contentLength(); // size_t:  ContentLength of the request (not avaiable in Handler::canHandle)\r\nrequest->multipart();     // bool:    True if the request has content type \"multipart\"\r\n```\r\n\r\n### Headers\r\n```cpp\r\n//List all collected headers\r\nint headers = request->headers();\r\nint i;\r\nfor(i=0;i<headers;i++){\r\n  AsyncWebHeader* h = request->getHeader(i);\r\n  Serial.printf(\"HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\r\n}\r\n\r\n//get specific header by name\r\nif(request->hasHeader(\"MyHeader\")){\r\n  AsyncWebHeader* h = request->getHeader(\"MyHeader\");\r\n  Serial.printf(\"MyHeader: %s\\n\", h->value().c_str());\r\n}\r\n```\r\n\r\n### GET, POST and FILE parameters\r\n```cpp\r\n//List all parameters\r\nint params = request->params();\r\nfor(int i=0;i<params;i++){\r\n  AsyncWebParameter* p = request->getParam(i);\r\n  if(p->isFile()){ //p->isPost() is also true\r\n    Serial.printf(\"FILE[%s]: %s, size: %u\\n\", p->name().c_str(), p->value().c_str(), p->size());\r\n  } else if(p->isPost()){\r\n    Serial.printf(\"POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\r\n  } else {\r\n    Serial.printf(\"GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\r\n  }\r\n}\r\n\r\n//Check if GET parameter exists\r\nbool exists = request->hasParam(\"download\");\r\nAsyncWebParameter* p = request->getParam(\"download\");\r\n\r\n//Check if POST (but not File) parameter exists\r\nbool exists = request->hasParam(\"download\", true);\r\nAsyncWebParameter* p = request->getParam(\"download\", true);\r\n\r\n//Check if FILE was uploaded\r\nbool exists = request->hasParam(\"download\", true, true);\r\nAsyncWebParameter* p = request->getParam(\"download\", true, true);\r\n```\r\n\r\n### FILE Upload handling\r\n```cpp\r\nvoid handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\r\n  if(!index){\r\n    Serial.printf(\"UploadStart: %s\\n\", filename.c_str());\r\n  }\r\n  for(size_t i=0; i<len; i++){\r\n    Serial.write(data[i]);\r\n  }\r\n  if(final){\r\n    Serial.printf(\"UploadEnd: %s, %u B\\n\", filename.c_str(), index+len);\r\n  }\r\n}\r\n```\r\n\r\n### Body data handling\r\n```cpp\r\nvoid handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\r\n  if(!index){\r\n    Serial.printf(\"BodyStart: %u B\\n\", total);\r\n  }\r\n  for(size_t i=0; i<len; i++){\r\n    Serial.write(data[i]);\r\n  }\r\n  if(index + len == total){\r\n    Serial.printf(\"BodyEnd: %u B\\n\", total);\r\n  }\r\n}\r\n```\r\n\r\n## Responses\r\n\r\n### Basic response with HTTP Code\r\n```cpp\r\nrequest->send(404); //Sends 404 File Not Found\r\n```\r\n\r\n### Basic response with HTTP Code and extra headers\r\n```cpp\r\nAsyncWebServerResponse *response = request->beginResponse(404); //Sends 404 File Not Found\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Basic response with string content\r\n```cpp\r\nrequest->send(200, \"text/plain\", \"Hello World!\");\r\n```\r\n\r\n### Basic response with string content and extra headers\r\n```cpp\r\nAsyncWebServerResponse *response = request->beginResponse(200, \"text/plain\", \"Hello World!\");\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Respond with content coming from a Stream\r\n```cpp\r\n//read 12 bytes from Serial and send them as Content Type text/plain\r\nrequest->send(Serial, \"text/plain\", 12);\r\n```\r\n\r\n### Respond with content coming from a Stream and extra headers\r\n```cpp\r\n//read 12 bytes from Serial and send them as Content Type text/plain\r\nAsyncWebServerResponse *response = request->beginResponse(Serial, \"text/plain\", 12);\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Respond with content coming from a File\r\n```cpp\r\n//Send index.htm with default content type\r\nrequest->send(SPIFFS, \"/index.htm\");\r\n\r\n//Send index.htm as text\r\nrequest->send(SPIFFS, \"/index.htm\", \"text/plain\");\r\n\r\n//Download index.htm\r\nrequest->send(SPIFFS, \"/index.htm\", String(), true);\r\n```\r\n\r\n### Respond with content coming from a File and extra headers\r\n```cpp\r\n//Send index.htm with default content type\r\nAsyncWebServerResponse *response = request->beginResponse(SPIFFS, \"/index.htm\");\r\n\r\n//Send index.htm as text\r\nAsyncWebServerResponse *response = request->beginResponse(SPIFFS, \"/index.htm\", \"text/plain\");\r\n\r\n//Download index.htm\r\nAsyncWebServerResponse *response = request->beginResponse(SPIFFS, \"/index.htm\", String(), true);\r\n\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Respond with content using a callback\r\n```cpp\r\n//send 128 bytes as plain text\r\nrequest->send(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -> size_t {\r\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\r\n  //index equals the amount of bytes that have been already sent\r\n  //You will not be asked for more bytes once the content length has been reached.\r\n  //Keep in mind that you can not delay or yield waiting for more data!\r\n  //Send what you currently have and you will be asked for more again\r\n  return mySource.read(buffer, maxLen);\r\n});\r\n```\r\n\r\n### Respond with content using a callback and extra headers\r\n```cpp\r\n//send 128 bytes as plain text\r\nAsyncWebServerResponse *response = request->beginResponse(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -> size_t {\r\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\r\n  //index equals the amount of bytes that have been already sent\r\n  //You will not be asked for more bytes once the content length has been reached.\r\n  //Keep in mind that you can not delay or yield waiting for more data!\r\n  //Send what you currently have and you will be asked for more again\r\n  return mySource.read(buffer, maxLen);\r\n});\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Chunked Response\r\nUsed when content length is unknown. Works best if the client supports HTTP/1.1\r\n```cpp\r\nAsyncWebServerResponse *response = request->beginChunkedResponse(\"text/plain\", [](uint8_t *buffer, size_t maxLen, size_t index) -> size_t {\r\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\r\n  //index equals the amount of bytes that have been already sent\r\n  //You will be asked for more data until 0 is returned\r\n  //Keep in mind that you can not delay or yield waiting for more data!\r\n  return mySource.read(buffer, maxLen);\r\n});\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nrequest->send(response);\r\n```\r\n\r\n### Print to response\r\n```cpp\r\nAsyncResponseStream *response = request->beginResponseStream(\"text/html\");\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nresponse->printf(\"<!DOCTYPE html><html><head><title>Webpage at %s</title></head><body>\", request->url().c_str());\r\n\r\nresponse->print(\"<h2>Hello \");\r\nresponse->print(request->client()->remoteIP());\r\nresponse->print(\"</h2>\");\r\n\r\nresponse->print(\"<h3>General</h3>\");\r\nresponse->print(\"<ul>\");\r\nresponse->printf(\"<li>Version: HTTP/1.%u</li>\", request->version());\r\nresponse->printf(\"<li>Method: %s</li>\", request->methodToString());\r\nresponse->printf(\"<li>URL: %s</li>\", request->url().c_str());\r\nresponse->printf(\"<li>Host: %s</li>\", request->host().c_str());\r\nresponse->printf(\"<li>ContentType: %s</li>\", request->contentType().c_str());\r\nresponse->printf(\"<li>ContentLength: %u</li>\", request->contentLength());\r\nresponse->printf(\"<li>Multipart: %s</li>\", request->multipart()?\"true\":\"false\");\r\nresponse->print(\"</ul>\");\r\n\r\nresponse->print(\"<h3>Headers</h3>\");\r\nresponse->print(\"<ul>\");\r\nint headers = request->headers();\r\nfor(int i=0;i<headers;i++){\r\n  AsyncWebHeader* h = request->getHeader(i);\r\n  response->printf(\"<li>%s: %s</li>\", h->name().c_str(), h->value().c_str());\r\n}\r\nresponse->print(\"</ul>\");\r\n\r\nresponse->print(\"<h3>Parameters</h3>\");\r\nresponse->print(\"<ul>\");\r\nint params = request->params();\r\nfor(int i=0;i<params;i++){\r\n  AsyncWebParameter* p = request->getParam(i);\r\n  if(p->isFile()){\r\n    response->printf(\"<li>FILE[%s]: %s, size: %u</li>\", p->name().c_str(), p->value().c_str(), p->size());\r\n  } else if(p->isPost()){\r\n    response->printf(\"<li>POST[%s]: %s</li>\", p->name().c_str(), p->value().c_str());\r\n  } else {\r\n    response->printf(\"<li>GET[%s]: %s</li>\", p->name().c_str(), p->value().c_str());\r\n  }\r\n}\r\nresponse->print(\"</ul>\");\r\n\r\nresponse->print(\"</body></html>\");\r\n//send the response last\r\nrequest->send(response);\r\n```\r\n\r\n### Send a large webpage from PROGMEM using callback response\r\nExample provided by [@nouser2013](https://github.com/nouser2013)\r\n```cpp\r\nconst char indexhtml[] PROGMEM = \"...\"; // large char array, tested with 5k\r\nAsyncWebServerResponse *response = request->beginResponse(\r\n  String(\"text/html\"),\r\n  strlen_P(indexhtml),\r\n  [](uint8_t *buffer, size_t maxLen, size_t alreadySent) -> size_t {\r\n    if (strlen_P(indexhtml+alreadySent)>maxLen) {\r\n      // We have more to read than fits in maxLen Buffer\r\n      memcpy_P((char*)buffer, indexhtml+alreadySent, maxLen);\r\n      return maxLen;\r\n    }\r\n    // Ok, last chunk\r\n    memcpy_P((char*)buffer, indexhtml+alreadySent, strlen_P(indexhtml+alreadySent));\r\n    return strlen_P(indexhtml+alreadySent); // Return from here to end of indexhtml\r\n  }\r\n);\r\nresponse->addHeader(\"Server\", \"MyServerString\");\r\nrequest->send(response);  \r\n```\r\n\r\n### ArduinoJson Basic Response\r\nThis way of sending Json is great for when the result is below 4KB \r\n```cpp\r\n#include \"AsyncJson.h\"\r\n#include \"ArduinoJson.h\"\r\n\r\n\r\nAsyncResponseStream *response = request->beginResponseStream(\"text/json\");\r\nDynamicJsonBuffer jsonBuffer;\r\nJsonObject &root = jsonBuffer.createObject();\r\nroot[\"heap\"] = ESP.getFreeHeap();\r\nroot[\"ssid\"] = WiFi.SSID();\r\nroot.printTo(*response);\r\nrequest->send(response);\r\n```\r\n\r\n### ArduinoJson Advanced Response\r\nThis response can handle really large Json objects (tested to 40KB)\r\nThere isn't any noticeable speed decrease for small results with the method above\r\nSince ArduinoJson does not allow reading parts of the string, the whole Json has to\r\nbe passed every time a chunks needs to be sent, which shows speed decrease proportional\r\nto the resulting json packets\r\n```cpp\r\n#include \"AsyncJson.h\"\r\n#include \"ArduinoJson.h\"\r\n\r\n\r\nAsyncJsonResponse * response = new AsyncJsonResponse();\r\nresponse->addHeader(\"Server\",\"ESP Async Web Server\");\r\nJsonObject& root = response->getRoot();\r\nroot[\"heap\"] = ESP.getFreeHeap();\r\nroot[\"ssid\"] = WiFi.SSID();\r\nresponse->setLength();\r\nrequest->send(response);\r\n```\r\n\r\n## Bad Responses\r\nSome responses are implemented, but you should not use them, because they do not conform to HTTP.\r\nThe following example will lead to unclean close of the connection and more time wasted\r\nthan providing the length of the content\r\n\r\n### Respond with content using a callback without content length to HTTP/1.0 clients\r\n```cpp\r\n//This is used as fallback for chunked responses to HTTP/1.0 Clients\r\nrequest->send(\"text/plain\", 0, [](uint8_t *buffer, size_t maxLen, size_t index) -> size_t {\r\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\r\n  //You will be asked for more data until 0 is returned\r\n  //Keep in mind that you can not delay or yield waiting for more data!\r\n  return mySource.read(buffer, maxLen);\r\n});\r\n```\r\n\r\n## Async WebSocket Plugin\r\nThe server includes a web socket plugin which lets you define different WebSocket locations to connect to\r\nwithout starting another listening service or using different port\r\n\r\n### Async WebSocket Event\r\n```cpp\r\n\r\nvoid onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\r\n  if(type == WS_EVT_CONNECT){\r\n    //client connected\r\n    os_printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\r\n    client->printf(\"Hello Client %u :)\", client->id());\r\n    client->ping();\r\n  } else if(type == WS_EVT_DISCONNECT){\r\n    //client disconnected\r\n    os_printf(\"ws[%s][%u] disconnect: %u\\n\", server->url(), client->id());\r\n  } else if(type == WS_EVT_ERROR){\r\n    //error was received from the other end\r\n    os_printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\r\n  } else if(type == WS_EVT_PONG){\r\n    //pong message was received (in response to a ping request maybe)\r\n    os_printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len)?(char*)data:\"\");\r\n  } else if(type == WS_EVT_DATA){\r\n    //data packet\r\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\r\n    if(info->num == 0 && info->final && info->index == 0 && info->len == len){\r\n      //the whole message is in a single frame and we got all of it's data\r\n      os_printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT)?\"text\":\"binary\", info->len);\r\n      if(info->opcode == WS_TEXT){\r\n        data[len] = 0;\r\n        os_printf(\"%s\\n\", (char*)data);\r\n      } else {\r\n        for(size_t i=0; i < info->len; i++){\r\n          os_printf(\"%02x \", data[i]);\r\n        }\r\n        os_printf(\"\\n\");\r\n      }\r\n      if(info->opcode == WS_TEXT)\r\n        client->text(\"I got your text message\");\r\n      else\r\n        client->binary(\"I got your binary message\");\r\n    } else {\r\n      //message is comprised of multiple frames or the frame is split into multiple packets\r\n      if(info->index == 0){\r\n        if(info->num == 0)\r\n          os_printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT)?\"text\":\"binary\");\r\n        os_printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\r\n      }\r\n\r\n      os_printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT)?\"text\":\"binary\", info->index, info->index + len);\r\n      if(info->message_opcode == WS_TEXT){\r\n        data[len] = 0;\r\n        os_printf(\"%s\\n\", (char*)data);\r\n      } else {\r\n        for(size_t i=0; i < len; i++){\r\n          os_printf(\"%02x \", data[i]);\r\n        }\r\n        os_printf(\"\\n\");\r\n      }\r\n\r\n      if((info->index + len) == info->len){\r\n        os_printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\r\n        if(info->final){\r\n          os_printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT)?\"text\":\"binary\");\r\n          if(info->message_opcode == WS_TEXT)\r\n            client->text(\"I got your text message\");\r\n          else\r\n            client->binary(\"I got your binary message\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Methods for sending data to a socket client\r\n```cpp\r\n//Server methods\r\nAsyncWebSocket ws(\"/ws\");\r\n//printf to a client\r\nws.printf([client id], [arguments...])\r\n//printf to all clients\r\nws.printfAll([arguments...])\r\n//send text to a client\r\nws.text([client id], [(char*)text])\r\nws.text([client id], [text], [len])\r\n//send text to all clients\r\nws.textAll([(char*text])\r\nws.textAll([text], [len])\r\n//send binary to a client\r\nws.binary([client id], [(char*)binary])\r\nws.binary([client id], [binary], [len])\r\n//send binary to all clients\r\nws.binaryAll([(char*binary])\r\nws.binaryAll([binary], [len])\r\n\r\n//client methods\r\nAsyncWebSocketClient * client;\r\n//printf to a client\r\nclient->printf([arguments...])\r\n//send text to a client\r\nclient->text([(char*)text])\r\nclient->text([text], [len])\r\n//send binary to a client\r\nclient->binary([(char*)binary])\r\nclient->binary([binary], [len])\r\n\r\n```\r\n\r\n\r\n## Setting up the server\r\n```cpp\r\n#include \"ESPAsyncTCP.h\"\r\n#include \"ESPAsyncWebServer.h\"\r\n\r\nAsyncWebServer server(80);\r\nAsyncWebSocket control_ws(\"/control\"); // access at ws://[esp ip]/control\r\nAsyncWebSocket data_ws(\"/data\"); // access at ws://[esp ip]/data\r\n\r\nconst char* ssid = \"your-ssid\";\r\nconst char* password = \"your-pass\";\r\nconst char* http_username = \"admin\";\r\nconst char* http_password = \"admin\";\r\n\r\nvoid onRequest(AsyncWebServerRequest *request){\r\n  //Handle Unknown Request\r\n  request->send(404);\r\n}\r\n\r\nvoid onBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\r\n  //Handle body\r\n}\r\n\r\nvoid onUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\r\n  //Handle upload\r\n}\r\n\r\nvoid onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\r\n  //Handle WebSocket event\r\n}\r\n\r\nvoid setup(){\r\n  Serial.begin(115200);\r\n  WiFi.mode(WIFI_STA);\r\n  WiFi.begin(ssid, password);\r\n  if (WiFi.waitForConnectResult() != WL_CONNECTED) {\r\n    Serial.printf(\"WiFi Failed!\\n\");\r\n    return;\r\n  }\r\n  \r\n  // attach Async WebSockets\r\n  control_ws.onEvent(onEvent);\r\n  server.addHandler(&control_ws);\r\n  data_ws.onEvent(onEvent);\r\n  server.addHandler(&data_ws);\r\n  \r\n  // respond to GET requests on URL /heap\r\n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest *request){\r\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\r\n  });\r\n  \r\n  // upload a file to /upload\r\n  server.on(\"/upload\", HTTP_POST, [](AsyncWebServerRequest *request){\r\n    request->send(200);\r\n  }, handleUpload);\r\n  \r\n  // send a file when /index is requested\r\n  server.on(\"/index\", HTTP_ANY, [](AsyncWebServerRequest *request){\r\n    request->send(SPIFFS, \"/index.htm\");\r\n  });\r\n  \r\n  // HTTP basic authentication\r\n  server.on(\"/login\", HTTP_GET, [](AsyncWebServerRequest *request){\r\n    if(!request->authenticate(http_username, http_password))\r\n        return request->requestAuthentication();\r\n    request->send(200, \"text/plain\", \"Login Success!\");\r\n  });\r\n  \r\n  // attach filesystem root at URL /fs \r\n  server.serveStatic(\"/fs\", SPIFFS, \"/\");\r\n  \r\n  // Catch-All Handlers\r\n  // Any request that can not find a Handler that canHandle it\r\n  // ends in the callbacks below.\r\n  server.onNotFound(onRequest);\r\n  server.onFileUpload(onUpload);\r\n  server.onRequestBody(onBody);\r\n  \r\n  server.begin();\r\n}\r\n\r\nvoid loop(){}\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}